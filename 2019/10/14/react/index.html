<!DOCTYPE html>





<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.4.0">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.4.0">
  <link rel="mask-icon" href="/images/logo.svg?v=7.4.0" color="#222">

<link rel="stylesheet" href="/css/main.css?v=7.4.0">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.4.0',
    exturl: false,
    sidebar: {"position":"right","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="react面试，2019年，记录下来">
<meta name="keywords" content="前端,JS">
<meta property="og:type" content="article">
<meta property="og:title" content="react">
<meta property="og:url" content="http://houzezhou.github.io/2019/10/14/react/index.html">
<meta property="og:site_name" content="二狗">
<meta property="og:description" content="react面试，2019年，记录下来">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-10-15T01:41:09.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="react">
<meta name="twitter:description" content="react面试，2019年，记录下来">
  <link rel="canonical" href="http://houzezhou.github.io/2019/10/14/react/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>react | 二狗</title>
  








  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">
  <div class="container use-motion">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">二狗</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
      
      
      
        
        <li class="menu-item menu-item-首页">
      
    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-标签">
      
    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-分类">
      
    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
      
      
      
        
        <li class="menu-item menu-item-时间轴">
      
    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>时间轴</a>

  </li>
  </ul>

    

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
      <article itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block post">
    <link itemprop="mainEntityOfPage" href="http://houzezhou.github.io/2019/10/14/react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Roman Pearce">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="二狗">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">react

          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              
                
              

              <time title="创建时间：2019-10-14 10:54:05" itemprop="dateCreated datePublished" datetime="2019-10-14T10:54:05+08:00">2019-10-14</time>
            </span>
          
            

            
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-10-15 09:41:09" itemprop="dateModified" datetime="2019-10-15T09:41:09+08:00">2019-10-15</time>
              </span>
            
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/前端/" itemprop="url" rel="index"><span itemprop="name">前端</span></a></span>

                
                
              
            </span>
          

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>react面试，2019年，记录下来</p>
<a id="more"></a>
<p>常见react面试题汇总（适合中级前端）<br><a href="https://segmentfault.com/a/1190000016885832?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016885832?utm_source=tag-newest</a><br> react.js javascript 58.8k 次阅读  ·  读完需要 27 分钟<br>已经开源<br>地址：<a href="https://github.com/nanhupatar" target="_blank" rel="noopener">https://github.com/nanhupatar</a>…<br>关注我们团队：<br>图片描述</p>
<h5 id="一、React-中-keys-的作用是什么？"><a href="#一、React-中-keys-的作用是什么？" class="headerlink" title="一、React 中 keys 的作用是什么？"></a>一、React 中 keys 的作用是什么？</h5><p>Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;this.state.todoItems.map((&#123;item, key&#125;) =&gt; &#123;</span><br><span class="line">        return &lt;li key=&#123;key&#125;&gt;&#123;item&#125;&lt;/li&gt;</span><br><span class="line">      &#125;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。</p>
<h5 id="二、调用-setState-之后发生了什么？"><a href="#二、调用-setState-之后发生了什么？" class="headerlink" title="二、调用 setState 之后发生了什么？"></a>二、调用 setState 之后发生了什么？</h5><p>在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。</p>
<h5 id="三、react-生命周期函数"><a href="#三、react-生命周期函数" class="headerlink" title="三、react 生命周期函数"></a>三、react 生命周期函数</h5><p>初始化阶段：</p>
<ul>
<li>getDefaultProps:获取实例的默认属性</li>
<li>getInitialState:获取每个实例的初始化状态</li>
<li>componentWillMount：组件即将被装载、渲染到页面上</li>
<li>render:组件在这里生成虚拟的 DOM 节点</li>
<li>componentDidMount:组件真正在被装载之后</li>
</ul>
<p>运行中状态：</p>
<ul>
<li>componentWillReceiveProps:组件将要接收到属性的时候调用</li>
<li>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</li>
<li>componentWillUpdate:组件即将更新不能修改属性和状态</li>
<li>render:组件重新描绘</li>
<li>componentDidUpdate:组件已经更新</li>
</ul>
<p>销毁阶段：</p>
<ul>
<li>componentWillUnmount:组件即将销毁</li>
</ul>
<h5 id="四、shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#四、shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="四、shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>四、shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h5><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>
<h5 id="五、为什么虚拟-dom-会提高性能-必考"><a href="#五、为什么虚拟-dom-会提高性能-必考" class="headerlink" title="五、为什么虚拟 dom 会提高性能?(必考)"></a>五、为什么虚拟 dom 会提高性能?(必考)</h5><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>
<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<p>参考 <a href="https://www.zhihu.com/question/29504639?sort=created" target="_blank" rel="noopener">如何理解虚拟 DOM?-zhihu</a></p>
<h5 id="六、react-diff-原理（常考，大厂必考）"><a href="#六、react-diff-原理（常考，大厂必考）" class="headerlink" title="六、react diff 原理（常考，大厂必考）"></a>六、react diff 原理（常考，大厂必考）</h5><p>把树形结构按照层级分解，只比较同级元素。<br>给列表结构的每个单元添加唯一的 key 属性，方便比较。<br>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）<br>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.<br>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。<br>参考：React 的 diff 算法</p>
<h5 id="七、React-中-refs-的作用是什么？"><a href="#七、React-中-refs-的作用是什么？" class="headerlink" title="七、React 中 refs 的作用是什么？"></a>七、React 中 refs 的作用是什么？</h5><p>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class CustomForm extends Component &#123;</span><br><span class="line">  handleSubmit = () =&gt; &#123;</span><br><span class="line">    console.log(&quot;Input Value: &quot;, this.input.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&apos;text&apos;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function CustomForm (&#123;handleSubmit&#125;) &#123;</span><br><span class="line">  let inputElement</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;() =&gt; handleSubmit(inputElement.value)&#125;&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&apos;text&apos;</span><br><span class="line">        ref=&#123;(input) =&gt; inputElement = input&#125; /&gt;</span><br><span class="line">      &lt;button type=&apos;submit&apos;&gt;Submit&lt;/button&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="八、如果你创建了类似于下面的-Twitter-元素，那么它相关的类定义是啥样子的？"><a href="#八、如果你创建了类似于下面的-Twitter-元素，那么它相关的类定义是啥样子的？" class="headerlink" title="八、如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？"></a>八、如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=&apos;tylermcginnis33&apos;&gt;</span><br><span class="line">  &#123;(user) =&gt; user === null</span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Badge info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import fetchUser from &apos;twitter&apos;</span><br><span class="line">// fetchUser take in a username returns a promise</span><br><span class="line">// which will resolve with that username&apos;s data.</span><br><span class="line">class Twitter extends Component &#123;</span><br><span class="line">  // finish this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children 进行调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component, PropTypes &#125; from &apos;react&apos;</span><br><span class="line">import fetchUser from &apos;twitter&apos;</span><br><span class="line">class Twitter extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    user: null,</span><br><span class="line">  &#125;</span><br><span class="line">  static propTypes = &#123;</span><br><span class="line">    username: PropTypes.string.isRequired,</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    fetchUser(this.props.username)</span><br><span class="line">      .then((user) =&gt; this.setState(&#123;user&#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    return this.props.children(this.state.user)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI 界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修改下回调函数即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Twitter username=&apos;tylermcginnis33&apos;&gt;</span><br><span class="line">  &#123;(user) =&gt; user === null</span><br><span class="line">    ? &lt;Loading /&gt;</span><br><span class="line">    : &lt;Profile info=&#123;user&#125; /&gt;&#125;</span><br><span class="line">&lt;/Twitter&gt;</span><br></pre></td></tr></table></figure>

<h5 id="九、展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><a href="#九、展示组件-Presentational-component-和容器组件-Container-component-之间有何不同" class="headerlink" title="九、展示组件(Presentational component)和容器组件(Container component)之间有何不同"></a>九、展示组件(Presentational component)和容器组件(Container component)之间有何不同</h5><ul>
<li>展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。</li>
<li>容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。</li>
</ul>
<h5 id="十、类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><a href="#十、类组件-Class-component-和函数式组件-Functional-component-之间有何不同" class="headerlink" title="十、类组件(Class component)和函数式组件(Functional component)之间有何不同"></a>十、类组件(Class component)和函数式组件(Functional component)之间有何不同</h5><ul>
<li>类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态</li>
<li>当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件<h5 id="十一、-组件的-状态-state-和属性-props-之间有何不同"><a href="#十一、-组件的-状态-state-和属性-props-之间有何不同" class="headerlink" title="十一、(组件的)状态(state)和属性(props)之间有何不同"></a>十一、(组件的)状态(state)和属性(props)之间有何不同</h5></li>
<li>State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。</li>
<li>Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。</li>
</ul>
<h5 id="十二、何为受控组件-controlled-component"><a href="#十二、何为受控组件-controlled-component" class="headerlink" title="十二、何为受控组件(controlled component)"></a>十二、何为受控组件(controlled component)</h5><p>在 HTML 中，类似 input, textarea 和 select 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。</p>
<h5 id="十三、何为高阶组件-higher-order-component"><a href="#十三、何为高阶组件-higher-order-component" class="headerlink" title="十三、何为高阶组件(higher order component)"></a>十三、何为高阶组件(higher order component)</h5><p>高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。</p>
<h5 id="十四、为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><a href="#十四、为什么建议传递给-setState-的参数是一个-callback-而不是一个对象" class="headerlink" title="十四、为什么建议传递给 setState 的参数是一个 callback 而不是一个对象"></a>十四、为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</h5><p>因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。</p>
<h5 id="十五、除了在构造函数中绑定-this，还有其它方式吗"><a href="#十五、除了在构造函数中绑定-this，还有其它方式吗" class="headerlink" title="十五、除了在构造函数中绑定 this，还有其它方式吗"></a>十五、除了在构造函数中绑定 this，还有其它方式吗</h5><p>你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。</p>
<h5 id="十六、-在构造函数中-调用-super-props-的目的是什么"><a href="#十六、-在构造函数中-调用-super-props-的目的是什么" class="headerlink" title="十六、(在构造函数中)调用 super(props) 的目的是什么"></a>十六、(在构造函数中)调用 super(props) 的目的是什么</h5><p>在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。</p>
<h5 id="十七、应该在-React-组件的何处发起-Ajax-请求"><a href="#十七、应该在-React-组件的何处发起-Ajax-请求" class="headerlink" title="十七、应该在 React 组件的何处发起 Ajax 请求"></a>十七、应该在 React 组件的何处发起 Ajax 请求</h5><p>在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。</p>
<h5 id="十八、描述事件在-React-中的处理方式。"><a href="#十八、描述事件在-React-中的处理方式。" class="headerlink" title="十八、描述事件在 React 中的处理方式。"></a>十八、描述事件在 React 中的处理方式。</h5><p>为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。</p>
<p>这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。</p>
<h5 id="十九、createElement-和-cloneElement-有什么区别？"><a href="#十九、createElement-和-cloneElement-有什么区别？" class="headerlink" title="十九、createElement 和 cloneElement 有什么区别？"></a>十九、createElement 和 cloneElement 有什么区别？</h5><p>React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    type,</span><br><span class="line">    [props],</span><br><span class="line">    [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.cloneElement(</span><br><span class="line">  element,</span><br><span class="line">  [props],</span><br><span class="line">  [...children]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="二十、React-中有三种构建组件的方式"><a href="#二十、React-中有三种构建组件的方式" class="headerlink" title="二十、React 中有三种构建组件的方式"></a>二十、React 中有三种构建组件的方式</h5><p>React.createClass()、ES6 class 和无状态函数。</p>
<h5 id="二十一、react-组件的划分业务组件技术组件？"><a href="#二十一、react-组件的划分业务组件技术组件？" class="headerlink" title="二十一、react 组件的划分业务组件技术组件？"></a>二十一、react 组件的划分业务组件技术组件？</h5><ul>
<li>根据组件的职责通常把组件分为 UI 组件和容器组件。</li>
<li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li>
<li>两者通过 React-Redux 提供 connect 方法联系起来。</li>
</ul>
<h5 id="二十二、简述-flux-思想"><a href="#二十二、简述-flux-思想" class="headerlink" title="二十二、简述 flux 思想"></a>二十二、简述 flux 思想</h5><p>Flux 的最大特点，就是数据的”单向流动”。</p>
<ol>
<li>用户访问 View</li>
<li>View 发出用户的 Action</li>
<li>Dispatcher 收到 Action，要求 Store 进行相应的更新</li>
<li>Store 更新后，发出一个”change”事件</li>
<li>View 收到”change”事件后，更新页面</li>
</ol>
<h5 id="二十三、React-项目用过什么脚手架（本题是开放性题目）"><a href="#二十三、React-项目用过什么脚手架（本题是开放性题目）" class="headerlink" title="二十三、React 项目用过什么脚手架（本题是开放性题目）"></a>二十三、React 项目用过什么脚手架（本题是开放性题目）</h5><p>creat-react-app Yeoman 等</p>
<h5 id="二十四、了解-redux-么，说一下-redux-把"><a href="#二十四、了解-redux-么，说一下-redux-把" class="headerlink" title="二十四、了解 redux 么，说一下 redux 把"></a>二十四、了解 redux 么，说一下 redux 把</h5><ul>
<li>redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰</li>
<li>新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们</li>
</ul>
<h5 id="二十五、redux-有什么缺点"><a href="#二十五、redux-有什么缺点" class="headerlink" title="二十五、redux 有什么缺点"></a>二十五、redux 有什么缺点</h5><ul>
<li>一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。</li>
<li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。</li>
</ul>

    </div>

    
    
    
        
      

      <footer class="post-footer">
          
            
          
          <div class="post-tags">
            
              <a href="/tags/前端/" rel="tag"># 前端</a>
            
              <a href="/tags/JS/" rel="tag"># JS</a>
            
          </div>
        

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
              
                <a href="/2019/10/14/微博/" rel="next" title="微博">
                  <i class="fa fa-chevron-left"></i> 微博
                </a>
              
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
              
                <a href="/2019/10/14/琐碎/" rel="prev" title="琐碎woca">
                  琐碎woca <i class="fa fa-chevron-right"></i>
                </a>
              
            </div>
          </div>
        
      </footer>
    
  </div>
  
  
  
  </article>

  </div>


          </div>
          

        </div>
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
        
        
        
        
      

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#一、React-中-keys-的作用是什么？"><span class="nav-number">1.</span> <span class="nav-text">一、React 中 keys 的作用是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二、调用-setState-之后发生了什么？"><span class="nav-number">2.</span> <span class="nav-text">二、调用 setState 之后发生了什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三、react-生命周期函数"><span class="nav-number">3.</span> <span class="nav-text">三、react 生命周期函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#四、shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><span class="nav-number">4.</span> <span class="nav-text">四、shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#五、为什么虚拟-dom-会提高性能-必考"><span class="nav-number">5.</span> <span class="nav-text">五、为什么虚拟 dom 会提高性能?(必考)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#六、react-diff-原理（常考，大厂必考）"><span class="nav-number">6.</span> <span class="nav-text">六、react diff 原理（常考，大厂必考）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#七、React-中-refs-的作用是什么？"><span class="nav-number">7.</span> <span class="nav-text">七、React 中 refs 的作用是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#八、如果你创建了类似于下面的-Twitter-元素，那么它相关的类定义是啥样子的？"><span class="nav-number">8.</span> <span class="nav-text">八、如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#九、展示组件-Presentational-component-和容器组件-Container-component-之间有何不同"><span class="nav-number">9.</span> <span class="nav-text">九、展示组件(Presentational component)和容器组件(Container component)之间有何不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十、类组件-Class-component-和函数式组件-Functional-component-之间有何不同"><span class="nav-number">10.</span> <span class="nav-text">十、类组件(Class component)和函数式组件(Functional component)之间有何不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十一、-组件的-状态-state-和属性-props-之间有何不同"><span class="nav-number">11.</span> <span class="nav-text">十一、(组件的)状态(state)和属性(props)之间有何不同</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十二、何为受控组件-controlled-component"><span class="nav-number">12.</span> <span class="nav-text">十二、何为受控组件(controlled component)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十三、何为高阶组件-higher-order-component"><span class="nav-number">13.</span> <span class="nav-text">十三、何为高阶组件(higher order component)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十四、为什么建议传递给-setState-的参数是一个-callback-而不是一个对象"><span class="nav-number">14.</span> <span class="nav-text">十四、为什么建议传递给 setState 的参数是一个 callback 而不是一个对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十五、除了在构造函数中绑定-this，还有其它方式吗"><span class="nav-number">15.</span> <span class="nav-text">十五、除了在构造函数中绑定 this，还有其它方式吗</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十六、-在构造函数中-调用-super-props-的目的是什么"><span class="nav-number">16.</span> <span class="nav-text">十六、(在构造函数中)调用 super(props) 的目的是什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十七、应该在-React-组件的何处发起-Ajax-请求"><span class="nav-number">17.</span> <span class="nav-text">十七、应该在 React 组件的何处发起 Ajax 请求</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十八、描述事件在-React-中的处理方式。"><span class="nav-number">18.</span> <span class="nav-text">十八、描述事件在 React 中的处理方式。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#十九、createElement-和-cloneElement-有什么区别？"><span class="nav-number">19.</span> <span class="nav-text">十九、createElement 和 cloneElement 有什么区别？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二十、React-中有三种构建组件的方式"><span class="nav-number">20.</span> <span class="nav-text">二十、React 中有三种构建组件的方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二十一、react-组件的划分业务组件技术组件？"><span class="nav-number">21.</span> <span class="nav-text">二十一、react 组件的划分业务组件技术组件？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二十二、简述-flux-思想"><span class="nav-number">22.</span> <span class="nav-text">二十二、简述 flux 思想</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二十三、React-项目用过什么脚手架（本题是开放性题目）"><span class="nav-number">23.</span> <span class="nav-text">二十三、React 项目用过什么脚手架（本题是开放性题目）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二十四、了解-redux-么，说一下-redux-把"><span class="nav-number">24.</span> <span class="nav-text">二十四、了解 redux 么，说一下 redux 把</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二十五、redux-有什么缺点"><span class="nav-number">25.</span> <span class="nav-text">二十五、redux 有什么缺点</span></a></li></ol></div>
        
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Roman Pearce</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        
          <a href="/archives">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
    
      
      
      <div class="site-state-item site-state-categories">
        
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span>
        
      </div>
    
      
      
      <div class="site-state-item site-state-tags">
        
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
        
      </div>
    
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roman Pearce</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.9.0</div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.4.0</div>

        












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js?v=3.1.0"></script>
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
<script src="/js/utils.js?v=7.4.0"></script><script src="/js/motion.js?v=7.4.0"></script>
<script src="/js/schemes/muse.js?v=7.4.0"></script>

<script src="/js/next-boot.js?v=7.4.0"></script>



  





















  

  

  

</body>
</html>
